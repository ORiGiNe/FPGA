-------------------------------------------------------------------------------------------------
 -- 1.0     ORiGiNe            2012          Modifications et nettoyage par ORiGiNe
-------------------------------------------------------------------------------------------------
 
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_unsigned.all;
 
entity 	TOP_UART is
	port(

    -- Clocks
    CLOCK_50 : in std_logic;          -- 50 MHz
 
    -- Buttons and switches
    KEY : in std_logic_vector(1 downto 0);         -- Push buttons
    SW : in std_logic_vector(3 downto 0);          -- Switches
 
    -- LED displays
    LEDG : out std_logic_vector(7 downto 0);       -- Green LEDs
 
    -- RS-232 interface
    UART_TXD : out std_logic;                      -- UART transmitter
	ArduinoFlowCtrl1_N : in std_logic; -- depuis arduino : "envoie l'octet suivant" CODEUR 1
	ArduinoFlowCtrl2_N : in std_logic; -- depuis arduino : "envoie l'octet suivant" CODEUR 2
	
	
	-- Encoders interface (2 encoders)
	Encoder1_A : in std_logic;
	Encoder1_B : in std_logic;
	Encoder2_A : in std_logic;
	Encoder2_B : in std_logic
	

);
end TOP_UART;
 
architecture rtl of TOP_UART is
 
	component miniUART 
	port (
		SysClk   : in  Std_Logic;  -- System Clock
		Reset    : in  Std_Logic;  -- Reset input
		TxD      : out Std_Logic;
		DataIn   : in  Std_Logic_Vector(15 downto 0); -- 
		GetFirstByte : in  Std_Logic; -- depuis arduino, octet 1
		GetSecondByte : in  Std_Logic; -- depuis arduino, octet 2
		LoadOut  : out Std_Logic; -- debug de load
		NextLoadOut   : out  Std_Logic;
		FistLoadOut   : out  Std_Logic); 
	end component;
	
	component Quadrature_decoder
	generic (
		sampling_interval : integer
	);
	port (
		readdata                 : out std_logic_vector(15 downto 0);       --        readdata
		clk                      : in  std_logic;             --             clock.clk
		reset                    : in  std_logic;             --             reset
		raz                      : in  std_logic;             -- Remise A Zero du compteur
		A                        : in  std_logic;             -- quadrature_signal
		B                        : in  std_logic;             --                  
		errorOut                 : out std_logic
	);
	end component;
	
	-- First encoder
	signal DataToTransmit1 : std_logic_vector(15 downto 0);
	signal RAZencoder1 : std_logic; -- RAZ du codeur 1
	
	-- Second encoder
 	signal DataToTransmit2 : std_logic_vector(15 downto 0);
	signal RAZencoder2 : std_logic; -- RAZ du codeur 2
	
	-- Both
	signal DataToTransmitBuffer : std_logic_vector(15 downto 0); -- le meme mais bufferisé
	signal NewRequest : std_logic; -- premier signal venant de arduino + RAZ variable
	signal Nextbyte : std_logic; -- Second signal venant arduino
	
	-- Gestion des erreurs
	signal ArduinoFuckedUp : std_logic;
	signal debug1 : std_logic;
	signal debug2 : std_logic;
	signal valeurLEDG4 : std_logic;
	signal NextLoadOut : std_logic;
	
	
begin
 
	U1 : miniUART 
	PORT MAP ( 
		SysClk   => CLOCK_50, 		--: in  Std_Logic;  -- System Clock
		Reset    => KEY(0), 		--: in  Std_Logic;  -- Reset input
		TxD      => UART_TXD, 		--: out Std_Logic; PIN 4 (GPIO_01)
		DataIn   => "1010111110010110",--DataToTransmitBuffer,	--: in  Std_Logic_Vector(7 downto 0); --
		GetFirstByte => NewRequest, -- pour permettre un load
		GetSecondByte => NextByte,
		LoadOut  => LEDG(7),
		NextLoadOut  => NextLoadOut,	
		FistLoadOut  => LEDG(5)
	);
	
	-- First encoder
	Quadrature_decoder1: Quadrature_decoder
	GENERIC MAP (
		sampling_interval => 21
	)
	PORT MAP (
		readdata => DataToTransmit1,
		clk => CLOCK_50,
		reset => KEY(0),
		raz => RAZencoder1,
		A => Encoder1_A,
		B => Encoder1_B,
		errorOut => LEDG(0)
	);
	
	-- Second encoder
	Quadrature_decoder2: Quadrature_decoder
	GENERIC MAP (
		sampling_interval => 21
	)
	PORT MAP (
		readdata => DataToTransmit2,
		clk => CLOCK_50,
		reset => KEY(0),
		raz => RAZencoder2,
		A => Encoder2_A,
		B => Encoder2_B,
		errorOut => LEDG(1)
	);

	-- On découpe la requete en plusieurs etats pour transmettre à l'arduino la valeur 'décodée' sur deux octets
	DataBuffer : process(CLOCK_50, KEY(0))
	variable RequestStarted1 : std_logic := '0';
	variable Init1 : std_logic := '0';
	variable RequestStarted2 : std_logic := '0';
	variable Init2 : std_logic := '0';
	begin
		if KEY(0) = '0' then
			ArduinoFuckedUp <= '0';
			RequestStarted1 := '0';
			RequestStarted2 := '0';
			NewRequest <= '0';
			NextByte <= '0';
			RAZencoder1 <= '0';
			RAZencoder2 <= '0';
		elsif Rising_Edge(CLOCK_50) then
			if ArduinoFlowCtrl1_N = '0' and ArduinoFlowCtrl2_N = '1' then -- L'arduino demande le premier codeur
				if RequestStarted1 = '0' and RequestStarted2 = '0' then
					Init1 := '1';
				else
					ArduinoFuckedUp <= '1';
					RAZencoder1 <= '0';
					NewRequest <= '0';
					NextByte <= '0';
					RequestStarted1 := '0';
					RequestStarted2 := '0';
					Init1 := '0';
					Init2 := '0';
				end if;
			elsif ArduinoFlowCtrl1_N = '1' and ArduinoFlowCtrl2_N = '1' and Init1 = '1'then
				if RequestStarted1 = '0' and RequestStarted2 = '0' then
					DataToTransmitBuffer <= DataToTransmit1;
					RAZencoder1 <= '1';
					NewRequest <= '1';
					NextByte <= '0';
					RequestStarted1 := '1';
				elsif RequestStarted1 = '1' and RequestStarted2 = '0' then
					RAZencoder1 <= '0';
					NewRequest <= '0';
					NextByte <= '1';
					RequestStarted1 := '0';
					Init1 := '0';
				else -- RequestStarted2 = '1' -> error
					ArduinoFuckedUp <= '1';
					RAZencoder1 <= '0';
					NewRequest <= '0';
					NextByte <= '0';
					RequestStarted1 := '0';
					RequestStarted2 := '0';
					Init1 := '0';
					Init2 := '0';
				end if;
			
			elsif ArduinoFlowCtrl1_N = '1' and ArduinoFlowCtrl2_N = '0' then -- L'arduino demande le deuxieme codeur
				if RequestStarted1 = '0' and RequestStarted2 = '0' then
					Init2 := '1';
				else
					ArduinoFuckedUp <= '1';
					RAZencoder1 <= '0';
					NewRequest <= '0';
					NextByte <= '0';
					RequestStarted1 := '0';
					RequestStarted2 := '0';
					Init1 := '0';
					Init2 := '0';
				end if;
			elsif ArduinoFlowCtrl1_N = '1' and ArduinoFlowCtrl2_N = '1' and Init2 = '1' then
				if RequestStarted2 = '0' and RequestStarted1 = '0' then
					DataToTransmitBuffer <= DataToTransmit2;
					RAZencoder2 <= '1';
					NewRequest <= '1';
					NextByte <= '0';
					RequestStarted2 := '1';
				elsif RequestStarted2 = '1' and RequestStarted1 = '0' then
					RAZencoder2 <= '0';
					NewRequest <= '0';
					NextByte <= '1';
					RequestStarted2 := '0';
					Init2:= '0';
				else -- RequestStarted1 = '1' -> error
					ArduinoFuckedUp <= '1';
					RAZencoder2 <= '0';
					NewRequest <= '0';
					NextByte <= '0';
					RequestStarted1 := '0';
					RequestStarted2 := '0';
					Init1 := '0';
					Init2 := '0';
				end if;
				
			else -- reset values
				NewRequest <= '0';
				NextByte <= '0';
				RAZencoder1 <= '0';
				RAZencoder2 <= '0';
			end if;
		end if;
		debug1 <= RequestStarted1;
		debug2 <= RequestStarted2;
	end process;
	
	UART_TXD <= 'Z';
	
	process(CLOCK_50, KEY(0))
	begin
		if KEY(0) = '0' then
			valeurLEDG4 <= '1';
		elsif Rising_Edge(CLOCK_50) then
			if NextLoadOut = '1' then 
				valeurLEDG4 <= '0' and valeurLEDG4;
			else
				valeurLEDG4 <= '1' and valeurLEDG4;
			end if;
		end if;
	end process;
	
	LEDG(4) <= valeurLEDG4;
	--LEDG(3) <= ArduinoFlowCtrl2_N;
	LEDG(2) <= debug1;
	LEDG(3) <= debug2;
end;